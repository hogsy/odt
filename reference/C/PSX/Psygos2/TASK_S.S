// WARNING: This file's extension ('.S') indicates that it may not have been a C or C++ file.
// It should contain Ghidra's best effort at decompiling the machine language to C, 
// but TDR does not currently attempt to handle assembly language or other non-C/C++ code differently, 
// so any decompiled code below may not reflect the original project source code for this file.
// If the source file is from a library, you should replace it with the original library version of the file.
// Otherwise, manual reconstruction of the code may be required, 
// Especially if the original source code was assembly language which used hardware features inaccessible to C.
#include "THISDUST.H"
#include "TASK_S.H"


// autogenerated function stub: 
// void _boss2_bss_size() /* _boss2_bss_size method signature is not contained in the debug symbol data. This is likely either a library function or the game was compiled without debug symbols. Please refer to the TDR documentation for additional guidance. */
void _boss2_bss_size() 
{ // line 11, offset 0x00000000
	return null;
}


// decompiled code
// original method signature: 
// void Task_CallSys() /* Task_CallSys method signature is not contained in the debug symbol data. This is likely either a library function or the game was compiled without debug symbols. Please refer to the TDR documentation for additional guidance. */
 // line 24, offset 0x80018000
/* WARNING: This function may have set the stack pointer */

void Task_CallSys(undefined *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5)

{
  (*(code *)param_1)(param_2,param_3,param_4,param_5);
  return;
}



// decompiled code
// original method signature: 
// void GtxTmd_RotN() /* GtxTmd_RotN method signature is not contained in the debug symbol data. This is likely either a library function or the game was compiled without debug symbols. Please refer to the TDR documentation for additional guidance. */
 // line 56, offset 0x80018044
void GtxTmd_RotN(undefined4 *puParm1,int iParm2,int iParm3)

{
  undefined4 in_zero;
  undefined4 in_at;
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  
  setCopReg(2,in_zero,*puParm1);
  setCopReg(2,in_at,puParm1[1]);
  puParm1 = puParm1 + 2;
  copFunction(2,0x486012);
  do {
    uVar1 = getCopReg(2,0x4800);
    iVar2 = getCopReg(2,0x5000);
    uVar3 = getCopReg(2,0x5800);
    setCopReg(2,in_zero,*puParm1);
    setCopReg(2,in_at,puParm1[1]);
    puParm1 = puParm1 + 2;
    copFunction(2,0x486012);
    *(uint *)(iParm2 + 8) = uVar1 & 0xffff | iVar2 << 0x10;
    *(undefined4 *)(iParm2 + 0xc) = uVar3;
    iParm3 = iParm3 + -1;
    iParm2 = iParm2 + 0x10;
  } while (iParm3 != 0);
  return;
}





